<!-- .slide: data-background="#111111" -->
# Wyrażenia lambda

## (w skrócie)

___

## Podstawowe wyrażenia lambda

```c++
[](){}; // empty lambda
[] { std::cout << "hello world" << std::endl; } // unnamed lambda

auto l = [] (int x, int y) { return x + y; };
auto result = l(2, 3); // result = 5
```

___

## Wyrażenia lambda

**Motywacja**: programowanie funkcyjne, nienazwane funkcje, uniwersalne przekazywanie funkcji.
<!-- .element: class="fragment fade-in" -->

Wyrażenia lambda są definiowane bezpośrednio w miejscu ich użycia. Zwykle sa używane jako parametr innej funkcji, która oczekuje wskaźnika do funkcji lub funktora, czy jakiegokolwiek obiektu wywoływalnego.
<!-- .element: class="fragment fade-in" -->

Stworzenie wyrażenia lambda powoduje, że kompilator utworzy jej unikalny typ - tzw. klasę domknięcia (closure class), która implementuje operator wywołania funkcji z kodem z wyrażenia.
<!-- .element: class="fragment fade-in" -->

Domknięcie jest obiektem klasy domknięcia. W zależności od typu przechwytywanego obiekt ten przechowuje referencje lub kopie zmiennych lokalnych.
<!-- .element: class="fragment fade-in" -->

___

## Typ zwracany z lambdy

Od C++14 automatyczna dedukcja typu zwracanego z lambd działa całkiem nieźle i zwykle nie ma potrzeby bezpośredniego podawania zwracanego typu. Można to jednak zrobić za pomocą operatora strzałki.
<!-- .element: class="fragment fade-in" -->

```c++
[](bool condition) -> int {
    if (condition) {
        return 1;
    } else {
        return 2;
    }
}
```
<!-- .element: class="fragment fade-in" -->

___

## Predykaty

Wyrażenia lambda są zwykle używane do tworzenia predykatów i funktorów wymaganych przez algorytmy w bibliotece standardowej (np. `std::sort`).
<!-- .element: class="fragment fade-in" -->

```c++

std::array<double, 6> values = { 5.0, 4.0, -1.4, 7.9, -8.22, 0.4 };

std::sort(values.begin(), values.end(), [](double a, double b) {
    return std::abs(a) < std::abs(b); //sort using absolute values
});
```
<!-- .element: class="fragment fade-in" -->

Wynik: `0.4, -1.4, 4.0, 5.0, 7.9, -8.22`
<!-- .element: class="fragment fade-in" -->

___

## Lista przechwytującą

```c++
int a {5};
auto add5 = [=](int x) { return x + a; };

int counter {};
auto inc = [&counter] { counter++; };

int even_count = 0;
for_each(v.begin(), v.end(), [&even_count] (int n) {
    cout << n;
    if (n % 2 == 0)
        ++even_count;
});

cout << "There are " << even_count
     << " even numbers in the vector." << endl;
```

___

## Lista przechwytującą (capture list)

Wewnątrz nawiasów `[]` możemy zawrzeć elementy, które lambda powinna przechwycić z zakresu, w jakim jest tworzona. Można również określić sposób ich przechwytywania.

* <!-- .element: class="fragment fade-in" --> puste nawiasy <code>[]</code> oznaczają, że wewnątrz lambdy nie można użyć żadnej zmiennej z zewnętrznego zakresu.
* <!-- .element: class="fragment fade-in" --> <code>[&]</code> oznacza, że zmienne z zakresu zewnętrznego są przechwytywane przez referencję, w tym wskaźnik <code>this</code>.
  * Funktor utworzony za pomocą wyrażenia lambda może czytać i zapisywać do dowolnej przechwyconej zmiennej i wszystkie są przechowywane przez referencję.
* <!-- .element: class="fragment fade-in" --> <code>[=]</code> oznacza, że zmienne z zakresu zewnętrznego są przechwytywane przez kopię, w tym wskaźnik <code>this</code>.
  * Wszystkie używane zmienne z zewnętrznego zakresu są kopiowane do wyrażenia lambda i mogą być tylko odczytywane.
  * wskaźnik `this` po skopiowaniu pozwala lambdzie modyfikować wszystkie zmienne klasy
  * Trzeba użyć słowa kluczowego `mutable`, aby móc modyfikować wartości przechwycone przez `=`.

___

## Lista przechwytującą

* <!-- .element: class="fragment fade-in" --> <code>[capture-list]</code> umożliwia jawne przechwytywanie konkretnych zmiennych z zewnętrznego zakresu poprzez wymienienie ich nazw na liście.
  * Domyślnie wszystkie elementy są przechwytywane przez kopię.
  * Jeśli zmienna ma zostać przechwycona przez referencję, należy ją poprzedzić znakiem `&`
  * Przykład: `[a, &b]`
* <!-- .element: class="fragment fade-in" --> <code>[*this]</code> (C++17) przechwytuje wskaźnik <code>this</code> przez kopię (tworzy kopię obecnego obiektu).

___
<!-- .slide: style="font-size: 0.95em" -->

## Generyczne lambdy (C++14)

W C++11 parametry wyrażenia lambda muszą być zadeklarowane przy użyciu określonego typu.
<!-- .element: class="fragment fade-in" -->

C++14 pozwala zadeklarować parametr jako `auto`.
<!-- .element: class="fragment fade-in" -->

```c++
auto lambda = [](auto x, auto y) { return x + y; }
```
<!-- .element: class="fragment fade-in" -->

W rezultacie kompilator generuje kod odpowiadający klasie zamknięcia podanej poniżej.
<!-- .element: class="fragment fade-in" -->

```c++
struct UnnamedClosureClass {// code generated by the compiler for above 1 line
    template <typename T1, typename T2>
    auto operator()(T1 x, T2 y) const {
        return x + y;
    }
};
auto lambda = UnnamedClosureClass();
```
<!-- .element: class="fragment fade-in" -->

___

## Wyrażenia przechwytywania w lambdzie (C++14)

Funkcje lambda w C++11 przechwytują zmienne zadeklarowane w zewnętrznych zakresach przez kopię lub referencję. Oznacza to, że mamy problem, jeśli chcemy używać semantyki przenoszenia.

C++14 umożliwia inicjalizację zmiennych na liście przechwytującej. Umożliwia to zarówno przechwytywanie przez przenoszenie, jak i deklarowanie nowych zmiennych lambdy.

```c++
auto lambda = [value = 1] { return value; };

std::unique_ptr<int> ptr(new int(10));
auto anotherLambda = [value = std::move(ptr)] { return *value; };
```

___

## Zadanie

Zmień funkcje w `main.cpp` na lambdy (`sortByArea`, `perimeterBiggerThan20`, `areaLessThan10`)

Zmień lambdę `areaLessThan10` na lambdę `areaLessThanX`, które dostanie `x = 10` na liście przechwytującej. Jaki jest problem?

Posłuż się `std::function`, by rozwiązać problem.
